package matrixmultiply;
import java.io.IOException;
import java.util.AbstractMap.SimpleEntry;
import java.util.ArrayList;
import java.util.List;
import java.util.Map.Entry;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.DoubleWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.FileSplit;
import org.apache.hadoop.mapreduce.lib.input.SequenceFileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;


public class TwoPassMatrixMultiplyFirstPass 
{
	public static class Map 
	extends Mapper<MatrixMultiply.IndexPair, 
	DoubleWritable,Text,Text>
	{
		private boolean matrixM;//are we mapping matrix M or N
		private Path path;
		private String inputPathM,inputPathN;
		private boolean debug = false;
		
		/**
		 * The Hadoop Map-Reduce framework spawns one map
		 * task for each InputSplit generated by the InputFormat 
		 * for this job. The framework first calls setup, 
		 * followed by map for each key/value pair in the 
		 * InputSplit
		 */
		public void setup(Context context)
		{
			Configuration conf = context.getConfiguration();
			inputPathM = conf.get("inputPathM");
			inputPathN = conf.get("inputPathN");
			debug = Boolean.parseBoolean(conf.get("debug"));
			FileSplit split = (FileSplit)context.getInputSplit();
			path = split.getPath();
			matrixM = path.toString().contains(inputPathM);
			if (debug)
			{
				System.out.println("Is matrix M " + matrixM + " for "+ path);
			}
		}
		
		public void map(MatrixMultiply.IndexPair key,
				DoubleWritable val,Context context) throws IOException, InterruptedException
		{
			int i,j,k;
			double value = val.get();
			Text outputKey = new Text();
			Text outputValue = new Text();
			
			if (debug)
			{				
				System.out.println(matrixM ? "M matrix ":"N matrix");
				System.out.println("Map input: (" + key.row + "," + key.col + ") " +  val.get());
			}
			if (matrixM)
			{
				i = key.row;
				k = key.col;
				outputKey.set(k + "");
				outputValue.set("M," + i + "," + value);
			}
			else
			{
				k = key.row;
				j = key.col;
				outputKey.set(k + "");
				outputValue.set("N," + j + "," + value);
			}
			try
			{
				context.write(outputKey,outputValue);
				if (debug)
				{
					System.out.println(matrixM ? "M matrix":"N matrix");
					System.out.println("Map output:key=" +outputKey+" value="+outputValue);
				}
			}
			catch(Exception ex)
			{
				ex.printStackTrace();
			}
		}
	}
	
	public static class Reduce extends Reducer<Text,
	Text,Text,Text>
	{		
		boolean debug;
		
		public void setup(Context context)
		{
			Configuration conf = context.getConfiguration();
			debug = Boolean.parseBoolean(conf.get("debug"));			
		}
		
		public void reduce(Text key,
				Iterable<Text> values,Context context) throws IOException, InterruptedException
		{
			Text outputValue;
			double mij,njk;
			String[] value;
			List<Entry<Integer,Double>> listM
			= new ArrayList<Entry<Integer,Double>>();
			List<Entry<Integer,Double>> listN
			= new ArrayList<Entry<Integer,Double>>();
			for (Text val : values)
			{
				value = val.toString().split(",");
				if (value[0].equals("M"))
				{
					listM.add(new SimpleEntry<Integer,Double>(Integer.parseInt(value[1]),Double.parseDouble(value[2])));					
				}
				else
				{
					listN.add(new SimpleEntry<Integer,Double>(Integer.parseInt(value[1]),Double.parseDouble(value[2])));										
				}
			}
			if (debug)
			{
				System.out.println("Reduce M list" + listM);
				System.out.println("Reduce N list" + listN);
			}
			outputValue = new Text();
			for (Entry<Integer,Double> m : listM)
			{
				mij = m.getValue();
				for (Entry<Integer,Double> n : listN)
				{
					njk = n.getValue();
					outputValue.set(m.getKey()+"," + n.getKey() + "," + (mij*njk));
					try
					{
						context.write(null, outputValue);
						if (debug)
						{
							System.out.println("Reduce output " + outputValue);
						}
					}
					catch (Exception ex)
					{
						ex.printStackTrace();
					}
				}
			}
		}
	}
	
	@SuppressWarnings("deprecation")
	public static void run(Configuration conf) throws Exception
	{
		Job pass1 = new Job(conf,"Matrix multiplication pass 1 of 2");
		pass1.setJarByClass(TwoPassMatrixMultiplyFirstPass.class);
		pass1.setInputFormatClass(SequenceFileInputFormat.class);
		pass1.setOutputFormatClass(TextOutputFormat.class);
		pass1.setMapperClass(Map.class);
		pass1.setReducerClass(Reduce.class);
		pass1.setMapOutputKeyClass(Text.class);
		//The input files location
		FileInputFormat.addInputPath(pass1, new Path(conf.get("inputPathM")));
		FileInputFormat.addInputPath(pass1, new Path(conf.get("inputPathN")));
			
		//The output files location
		//make sure you delete any previous
		//setup
		FileSystem fs = FileSystem.get(conf);
		fs.delete(new Path(conf.get("tempPath")));
		FileOutputFormat.setOutputPath(pass1, new Path(conf.get("tempPath")));
		boolean pass1Success = pass1.waitForCompletion(true);
		if (!pass1Success)
		{
			throw new Exception("Pass 1 of 2 failed");
		}
	}
}
